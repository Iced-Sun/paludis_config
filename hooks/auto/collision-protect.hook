#! /bin/bash

# Installation
# ============
#
# Copy or symlink into one of the following directories, making sure
# it is executable:
#
# * /etc/paludis/hooks/auto to install the hook for the default configuration
# * /etc/paludis-suffix/hooks/auto to install the hook for the
#   configuration used by --environment :suffix
# * ~/.paludis/hooks/auto to install the hook for the default
#   configuration for your user account
# * ~/.paludis-suffix/hooks/auto to install the hook for the
#   configuration used by --environment :suffix for your user account
# * /usr/share/paludis/hooks/auto to install the hooks for all
#   configurations and users
#
# Most people should probably use either /etc/paludis/hooks/auto or
# /usr/share/paludis/hooks/auto.

# You can have some extra control over the protection by setting the
# COLLISION_IGNORE variable in /etc/paludis/bashrc. It should be a
# space-seperated list of files or directories (including wildcards)
# for which collisions will be ignored (you can disable it completely
# by including / in the list). As with anything in bashrc, you can
# make it conditional on package name, version, phase of the moon, or
# whatever else you can express in bash code.

source "${PALUDIS_EBUILD_DIR}/echo_functions.bash"

hook_run_merger_check_post() {
    load_bashrc() {
        local CONFIG_PROTECT CONFIG_PROTECT_MASK
        for f in ${PALUDIS_BASHRC_FILES}; do
            [[ -f "${f}" ]] && source "${f}"
        done
    }
    load_bashrc

    if [[ " ${COLLISION_IGNORE} " == *" / "* ]]; then
        einfo_unhooked "\${COLLISION_IGNORE} contains /, skipping collision check"
        return 0
    fi

    einfo_unhooked "Checking for collisions..."

    # Uncomment this and the corresponding bit at the end if you
    # want to know how long it takes.
    ## "times" doesn't return real time, and "time" is too awkward to
    ## use in this context.
    #local start=( $( date '+%s %N' ) )

    # Some packages try to update the Info directory, but Paludis
    # manages that so it doesn't really matter.  For some reason, the
    # GCC Info directory gets installed with Paludis but not Portage,
    # so handle that too.
    local prunes=( -wholename ./usr/share/info/dir                -prune -or
                   -wholename ./usr/share/info/dir.gz             -prune -or
                   -wholename ./usr/share/info/dir.bz2            -prune -or
                   -wholename ./usr/share/gcc-data/*/info/dir     -prune -or
                   -wholename ./usr/share/gcc-data/*/info/dir.gz  -prune -or
                   -wholename ./usr/share/gcc-data/*/info/dir.bz2 -prune -or )

    # Don't expand wildcards in ${COLLISION_IGNORE} etc
    local oldset="${-}"
    set -f

    local ignore
    for ignore in ${COLLISION_IGNORE}; do
        # No need for a slash/wildcard here: if it's a directory, find
        # will prune it and all its contents, if not it'll just prune
        # that file.
        prunes+=( -wholename ".${ignore%/}" -prune -or )
    done

    local mask
    for mask in ${CONFIG_PROTECT_MASK}; do
        prunes+=( -wholename ".${mask}" ! -type d -print -or
                  -wholename ".${mask%/}/*" ! -type d -print -or )
    done

    local protect
    for protect in ${CONFIG_PROTECT}; do
        prunes+=( -wholename ".${protect}" ! -type d -prune -or
                  -wholename ".${protect%/}/*" ! -type d -prune -or )
    done

    [[ ${oldset} == *f* ]] || set +f

    # Use ls -d 2>/dev/null to find files that already exist.  The -d'\n'
    # is needed to stop xargs from interpreting special characters.  Use
    # cd to handle ${ROOT}, rather than adding it with sed, to avoid the
    # chance of evil characters messing things up.
    find_existing() {
        sed -e 's,^,.,' |
            ( cd "${ROOT}" && xargs -r -d'\n' ls -d 2>/dev/null ) |
            sed -e 's,^\.,,'
    }

    # Need silent to suppress warnings about the temporary directory in the VDB.
    local installed=( $( ${CAVE} --log-level silent \
                                 print-ids \
				 --matching "${CATEGORY}/${PN}:${SLOT}::${ROOT}" \
				 --format '=%c/%p%:%s\n' ) )

    cd "${IMAGE}"
    # Not using bash arrays here because it makes it harder to pass to
    # external commands.
    if [[ ${#installed[@]} -gt 0 ]]; then
        local inst_files="$( ${CAVE} --log-level silent \
                                     print-id-contents --all \
				     "${CATEGORY}/${PN}:${SLOT}::${ROOT}" \
				     --format '%n\n' |
                                 sort | find_existing )"
        local new_files="$( find . "${prunes[@]}" ! -type d -print |
                                sed -e 's,^\.,,' | sort )"
        local collisions="$( comm -2 -3 <( echo "${new_files}" ) \
                                        <( echo "${inst_files}" ) |
                                 find_existing )"
    else
        local collisions="$( find . "${prunes[@]}" ! -type d -print |
                                 sed -e 's,^\.,,' | find_existing )"
    fi

    # Handle the case that a package installs files to the same directory
    # as the previous version but under a different name, via symlinking.
    # For example, a package that's made multilib-aware (lib -> lib64) or
    # an X program that was moved from /usr/X11R6 to /usr.
    if [[ -n "${collisions}" && ${#installed[@]} -gt 0 ]]; then
        # Two files are "the same" for our purposes if they have the same
        # name and their directories (after resolving symlinks) have the
        # same device and inode numbers.
        dev_inode_names() {
            # first sed:   Find the directory names.
            # xargs stat:  Find the dev/inode numbers of said directories.
            # second sed:  Find the filenames.
            # ${2} "${1}": Optionally add the full path/filename to the end.
            paste <( sed -e 's,^\(.*\)/[^/]*$,.\1,' <<<"$1" |
                         ( cd "${ROOT}" && xargs -r -d'\n' \
                             stat -L -c '%D %i' 2>/dev/null ) ) \
                  <( sed -e 's,^.*/,,' <<<"$1" ) \
                  <( ${2} "${1}" )
        }

        # Find the info of all the potential collisions.  Sort it up to
        # but not including the first slash (i.e. up to the start of the
        # full pathname).
        local dins="$( dev_inode_names "${collisions}" echo |
                           LC_ALL=C sort -t/ -k1 )"

        # comm:  Chop off the pathname part and compare with the pathless
        #        info of the files from the previously installed version.
        # paste: Stick the pathnames back on.
        # sed:   Find those files that were /not/ in the installed version
        #        (aka the lines from comm that do not start with tabs) and
        #        chop off the dev/inode information, leaving only the
        #        pathnames.
        collisions="$( paste <( LC_ALL=C comm -2 <( cut -d/ -f1 <<<"${dins}" ) \
                                                 <( dev_inode_names \
                                                            "${inst_files}" : |
                                                        LC_ALL=C sort ) ) \
                             <( echo "${dins}" ) |
                           sed -ne 's,^[^\t][^/]*\(/.*\)$,\1,p' )"
    fi

    if [[ -n "${collisions}" ]]; then
        local okay=false file
        while read file; do
            eerror "${file} already exists in ${ROOT}"
        done <<<"${collisions}"
    else
        local okay=true
    fi

    # Uncomment this and the corresponding bit at the beginning if you
    # want to know how long it takes.
    #local end=( $( date '+%s %N' ) )
    #local elapsed=$(( (${end[0]} - ${start[0]}) * 1000
    #                    + (10#${end[1]}   / 1000000)
    #                    - (10#${start[1]} / 1000000) ))
    #einfo_unhooked "Elapsed time: $( printf %d.%03d \
    #                                     $(( ${elapsed} / 1000 )) \
    #                                     $(( ${elapsed} % 1000 )) ) seconds"

    if ${okay}; then
        einfo_unhooked "Hooray!  No collisions"
        return 0
    else
        eerror "Package collides with existing files"
        return 1
    fi
}

hook_auto_names() {
    echo merger_check_post
}

