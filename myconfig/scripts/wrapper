#!/bin/bash

## FIXME move the hard-coded config outwards

### TODO: source bashrc for CHOST
### TODO: support bashrc
### TODO: if cave can add an option --binary-path like --chroot-path, we can add set/repo bindist-laptop-x61
### TODO: or better, if there is an option --destination (so we can use 'cave resolve package --destination bindist-laptop-x61/installed-laptop-x61')

typical_env_for_cave() {
    EXHERES_PHASE=configure
    FILESYSTEM_LAYOUT=cross
    HOOK=ebuild_configure_pre

    PALUDIS_BASHRC_FILES=/etc/paludis/bashrc
    PALUDIS_CLIENT=CAVE
    PALUDIS_CONFIG_DIR=/etc/paludis/
    REPLACING_IDS=app-terminal/tmux-1.9a:0::installed
    REPODIR=/var/db/paludis/repositories/arbor
    REPOSITORY=arbor
    ROOT=/
    TARGETS=
    XDG_RUNTIME_DIR=/var/tmp/paludis/build/app-terminal-tmux-1.9a/temp/
}

#### Helper function ####
## string parser
remove_comment_and_platform() {
    sed -r -e 's/#.*//' -e 's/~//' -e '/^[[:blank:]]*$/d'
}

remove_custom_mark() {
    sed -e 's/+.*//' -e 's/&.*//'
}

find_set() {
    [[ x$1 == "xhost" ]] && echo ${CONFIG_DIR}/packages/hosts/$HOST || echo ${CONFIG_DIR}/packages/$1
}

## detect install destination, includes the ROOT of the chroot, and
## the LOCATION of the repository
# take the destination or target repository as the parameter; else a
# guess will be made from ${CAVE_RESOLVE_CMDLINE_make}
detect_destination() {
    local REPO

    ## if parameter is provided, the function is called by
    ## installed*.bash
    REPO=$1

    ## no parameter means the function is called by other *.bash
    if [[ x$1 == "x" ]]; then
	## in case of 
	if [[ x${CAVE_RESOLVE_CMDLINE_make} == "xc" ]]; then
	    pushd ${PALUDIS_CONFIG_DIR}/repositories >/dev/null
	    for repo in installed-chroot-*.bash; do
		REPO=${repo%.bash}

		# if chroot-path is provided, it dominates
		local REPO_ROOT=`./$repo self-invoking | sed -n -e 's/^root = // p'`
		if [[ $CAVE_RESOLVE_CMDLINE_chroot_path == $REPO_ROOT ]]; then
		    break
		fi
	    done
	    popd >/dev/null
	else
	    REPO=installed
	fi
    fi

    LOCATION=/var/db/paludis/repositories/$REPO
    WORLD=${LOCATION}/world
    if [[ $REPO != "installed" ]]; then
	NAME=${REPO#installed-chroot-}
	ROOT=/srv/linux/machine_components/systems/${NAME}
    fi
}

#### Initialize ####
initialize() {
    ## set directories: all paths are relative to $PALUDIS_CONFIG_DIR
    local SCRIPT_ABSOLUTE=$(realpath $0)
    PALUDIS_CONFIG_DIR=$(realpath $(dirname $(realpath $SCRIPT_ABSOLUTE))/../../)
    local SCRIPT_DIR=$(realpath $(dirname ${SCRIPT_ABSOLUTE}) --relative-base=${PALUDIS_CONFIG_DIR})
    CONFIG_DIR=$(dirname ${SCRIPT_DIR})

    ## determine actions
    local INVOKER=$(realpath -s $(realpath $(dirname $0))/$(basename $0) --relative-base=${PALUDIS_CONFIG_DIR})
    ACTION=$(echo ${INVOKER%.bash}/ | cut -d/ -f1)
    SUB_ACTION=$(echo ${INVOKER%.bash}/ | cut -d/ -f2)

    ## change PWD asap
    pushd $PALUDIS_CONFIG_DIR >/dev/null

    ## misc
    HOST=`hostname | cut -d. -f1`

    ## we need detect destination type and related configs
    if [[ $SELF_INVOKING != "yes" ]]; then
	if [[ $ACTION == "repositories" ]]; then
	    detect_destination $SUB_ACTION
	else
	    detect_destination
	fi
    fi
    
    ## SETS
    SETS=$(cd ${CONFIG_DIR}/packages && find . -type f -printf '%P\n')
    ACTIVE_SETS=( system x11 )
    ACTIVE_SETS+=( $(sort ${WORLD} <(printf '%s\n' ${SETS[@]} host) 2>/dev/null |uniq -d) )

    ## debug
    print_debug_info() {
	echo
	[[ $SELF_INVOKING == "yes" ]] && echo "============ SELF INVOKING Begin =============="
	echo "===== Host information ====="
	echo "Paludis config DIR:" ${PALUDIS_CONFIG_DIR}
	echo "Custom config DIR (relative):" ${CONFIG_DIR}
	echo "Action:" ${ACTION}`[[ x${SUB_ACTION} == "x" ]] || echo ::${SUB_ACTION}`
	echo "Host:" ${HOST}
	echo
	echo "===== Paludis information ====="
	echo "Destination:" ${LOCATION}
	echo "Sets:" ${SETS[@]}
	echo "Active sets:" ${ACTIVE_SETS[@]}
	echo "===== End debug information ====="
	[[ $SELF_INVOKING == "yes" ]] && echo "============ SELF INVOKING End =============="
	echo
    }
    [[ x$PALUDIS_CLIENT == "x" ]] && print_debug_info 1>&2
}

####### Action handlers #######
show_general() {
    echo world = ${WORLD}
}

show_repository_defaults() {
    echo names_cache = /var/cache/paludis/names
    echo write_cache = /var/cache/paludis/metadata
    echo sync_options = --git-clone-option=--depth=1 --git-pull-option=--depth=1  --git-fetch-option=--depth=1
}

show_repositories() {
    local REPO=${1%%-*}
    local SUB_REPO=${1#${REPO}}
    SUB_REPO=${SUB_REPO#-}
    
    case $1 in
	installed*)
	    detect_destination $1

	    echo format = exndbam
	    echo location = $LOCATION
	    [[ x$ROOT != "x" ]] && echo root = $ROOT
	    [[ x$NAME != "x" ]] && echo name = $NAME
	    echo split_debug_location = /usr/x86_64-pc-linux-gnu/lib/debug
	    echo tool_prefix = x86_64-pc-linux-gnu-
	    ;;
	binary*)
	    cat <<EOF
format = e
sync = git+ssh://git@github.com/sunbing81/${1}.git
sync_options = --no-reset
#importance = -1
EOF

	    if [[ x$HOST == xfs-3 ]]; then
		cat <<EOF
location = /srv/linux/paludis/repositories/$1
binary_destination = true
binary_distdir = /srv/linux/paludis/distfiles
binary_keywords_filter = amd64 ~amd64
binary_uri_prefix = mirror://exherbo-binary/

split_debug_location = /usr/x86_64-pc-linux-gnu/lib/debug
tool_prefix = x86_64-pc-linux-gnu-
EOF
	    else
		echo location = ${root}/var/db/paludis/repositories/$1
	    fi
	    ;;
	*)
	    echo "Unsupported repository" 1>&2
	    ;;
    esac
}

show_platforms() {
    cat <<EOF
### defaults
*/*		amd64 ~amd64
*/*[=scm]	~amd64
EOF
}

show_options() {
    echo "### Global options:"
    cat <<EOF
## disable everything by default
*/*			-*
*/*			parts:		-* binaries configuration data libraries
*/*			providers:	-*
*/*			linguas:	-* zh_CN

## build related
*/*			build_options:	symbols=strip -recommended_tests
*/*			targets:	-* x86_64-pc-linux-gnu
*/*			providers:	libelf
virtual/pkg-config	providers:	pkgconf

## system
*/*			pam systemd udev
*/*			providers:	libressl
*/*			providers:	systemd

## concurrenty/parellelism
*/*			threads openmp

## filesystem attributes
*/*			acl xattr

## language bindings
*/*			python_abis:	-*
*/*			lua_abis:	-*
*/*			ruby_abis:	-*

EOF

    ### option is generated before chroot-path is used, hence the following has no effect; use python bindings?
    #echo $LOCATION 1>&2
    #env 1>&2
    ## if ROOT is set, then it is a chroot
    if [[ x$ROOT != "x" && $ROOT != "/" ]]; then
	echo 
	echo "### Chroot options:"
	cat <<EOF
*/*			parts:		-* binaries libraries
EOF
    fi
    
    for set in ${ACTIVE_SETS[@]}; do
	echo
	echo "### Options for set --$set--"
	cat $(find_set $set) | remove_comment_and_platform | remove_custom_mark | awk '{if (NF>1) print}'
    done
}

show_package_unmask() {
    for set in ${ACTIVE_SETS[@]}; do
	echo
	echo "### Package unmasks for set --$set--"
	cat $(find_set $set) | remove_comment_and_platform | sed -r -n '/\+([[:punct:][:alnum:]]+)/ s/[[:blank:]]*([[:punct:][:alnum:]]+).*\+/\1/ p'
    done
}

show_mirrors() {
    SITES=( BJTU TSU USTC HEANET NETEASE BIR )
    BJTU=(http://mirror.bjtu.edu.cn
	  apache cpan cran 'ctan CTAN' debian freebsd 'gentoo gentoo/distfiles' gimp gnome gnu kde 'kernel kernel/pub' 'libreoffice tdf/libreoffice')
    TSU=( http://mirrors.tuna.tsinghua.edu.cn
	  apache 'ctan CTAN' 'cran CRAN' 'ctan CTAN' debian freebsd 'gentoo gentoo/distfiles' gnu 'kernel kernel/pub' opensuse )
    USTC=( http://mirrors.ustc.edu.cn
	   'cpan CPAN' 'cran CRAN' 'ctan CTAN' debian freebsd 'gentoo gentoo/distfiles' gnome gnu kde 'kernel linux-kernel' opensuse )
    HEANET=( http://heanet.dl.sourceforge.net sourceforge )
    NETEASE=( http://mirrors.163.com
	      cpan debian 'freebsd FreeBSD' 'gentoo gentoo/distfiles' 'opensuse openSUSE')
    BIR=( http://10.2.112.3 exherbo-binary )

    add_mirror()
    {
	url_base=$1
	set -- $2
    
	url="$url_base/${2:-$1}"
	name=$1

	num=${#MIRRORS[@]}
	for ((i=0; i<$num; i++)); do
	    set -- ${MIRRORS[i]}
	    if [[ $name == $1 ]]; then
		MIRRORS[i]+=" $url"
		return 0
	    fi
	done
	MIRRORS+=( "$name $url" )
	return 0
    }

    local MIRRORS=()
    for site in ${SITES[@]}; do
	eval site=\( \${${site}[@]} \)
	set -- ${site[@]}
	local url_base=$1
	shift
	while [[ $# -gt 0 ]]; do
	    add_mirror "$url_base" "$1"
	    shift
	done
    done

    for m in "${MIRRORS[@]}"; do
	echo ${m}
    done
}

show_suggestions() {
    for set in ${ACTIVE_SETS[@]}; do
	echo 
	echo "### Package suggestions for set --$set--"
	cat $(find_set $set) | remove_comment_and_platform | sed -r -n '/&/ s/[[:blank:]]*([[:punct:][:alnum:]]+).*&/\1\t/ p'
    done
}

show_sets() {
    cat $(find_set $1) | remove_comment_and_platform | awk '!/^[[:blank:]*]/ {print "* " $1}'
}

##### Main ####
[[ x$1 == 'xself-invoking' ]] && SELF_INVOKING=yes || SELF_INVOKING=
initialize

##### Dispatcher ####
if [[ -d ${CONFIG_DIR} ]]; then
    if type show_${ACTION} >/dev/null 2>&1; then
	show_${ACTION} ${SUB_ACTION}
    else
	echo "Not supported action: " ${ACTION} 1>&2
    fi
else
    echo "The configuration path does not exist."
fi

#### Finalize ####
popd >/dev/null

